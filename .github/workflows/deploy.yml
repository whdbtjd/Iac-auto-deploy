name: Auto Deploy Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch: # 수동 실행 가능

env:
  AWS_REGION: ap-northeast-2

jobs:
  # 변경사항 감지
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      frontend: ${{ steps.changes.outputs.frontend }}
      terraform: ${{ steps.changes.outputs.terraform }}
      ansible: ${{ steps.changes.outputs.ansible }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            backend:
              - 'backend/**'
            frontend:
              - 'frontend/**'
            terraform:
              - 'terraform/**'
            ansible:
              - 'ansible/**'

  # 인프라 배포 (조건부 타겟팅)
  deploy-infrastructure:
    needs: detect-changes
    if: |
      needs.detect-changes.outputs.terraform == 'true' ||
      needs.detect-changes.outputs.backend == 'true' ||
      needs.detect-changes.outputs.frontend == 'true' ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      # 기본 리소스 정보
      ec2-id-1: ${{ steps.terraform.outputs.ec2-id-1 }}
      ec2-id-2: ${{ steps.terraform.outputs.ec2-id-2 }}
      ec2-private-ip-1: ${{ steps.terraform.outputs.ec2-private-ip-1 }}
      ec2-private-ip-2: ${{ steps.terraform.outputs.ec2-private-ip-2 }}
      alb-dns: ${{ steps.terraform.outputs.alb-dns }}
      s3-bucket: ${{ steps.terraform.outputs.s3-bucket }}
      ssm-bucket: ${{ steps.terraform.outputs.ssm-bucket }}
      cloudfront-url: ${{ steps.terraform.outputs.cloudfront-url }}
      db-endpoint: ${{ steps.terraform.outputs.db-endpoint }}
      
      # 백엔드 API용 추가 정보들
      vpc-id: ${{ steps.terraform.outputs.vpc-id }}
      vpc-cidr: ${{ steps.terraform.outputs.vpc-cidr }}
      public-subnet-ids: ${{ steps.terraform.outputs.public-subnet-ids }}
      private-subnet-ids-was: ${{ steps.terraform.outputs.private-subnet-ids-was }}
      private-subnet-ids-db: ${{ steps.terraform.outputs.private-subnet-ids-db }}
      internet-gateway-id: ${{ steps.terraform.outputs.internet-gateway-id }}
      nat-gateway-ids: ${{ steps.terraform.outputs.nat-gateway-ids }}
      security-group-alb-id: ${{ steps.terraform.outputs.security-group-alb-id }}
      security-group-was-id: ${{ steps.terraform.outputs.security-group-was-id }}
      security-group-db-id: ${{ steps.terraform.outputs.security-group-db-id }}
      ec2-public-ips: ${{ steps.terraform.outputs.ec2-public-ips }}
      ec2-availability-zones: ${{ steps.terraform.outputs.ec2-availability-zones }}
      ec2-instance-types: ${{ steps.terraform.outputs.ec2-instance-types }}
      ec2-ami-id: ${{ steps.terraform.outputs.ec2-ami-id }}
      alb-arn: ${{ steps.terraform.outputs.alb-arn }}
      alb-availability-zones: ${{ steps.terraform.outputs.alb-availability-zones }}
      alb-listener-arn: ${{ steps.terraform.outputs.alb-listener-arn }}
      alb-target-group-name: ${{ steps.terraform.outputs.alb-target-group-name }}
      rds-instance-identifier: ${{ steps.terraform.outputs.rds-instance-identifier }}
      rds-availability-zone: ${{ steps.terraform.outputs.rds-availability-zone }}
      rds-multi-az: ${{ steps.terraform.outputs.rds-multi-az }}
      rds-engine: ${{ steps.terraform.outputs.rds-engine }}
      rds-engine-version: ${{ steps.terraform.outputs.rds-engine-version }}
      rds-instance-class: ${{ steps.terraform.outputs.rds-instance-class }}
      s3-bucket-region: ${{ steps.terraform.outputs.s3-bucket-region }}
      s3-website-endpoint: ${{ steps.terraform.outputs.s3-website-endpoint }}
      cloudfront-distribution-id: ${{ steps.terraform.outputs.cloudfront-distribution-id }}
      cloudfront-status: ${{ steps.terraform.outputs.cloudfront-status }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Terraform Plan (Conditional Targeting)
        working-directory: ./terraform
        run: |
          echo "Detected changes:"
          echo "- Backend: ${{ needs.detect-changes.outputs.backend }}"
          echo "- Frontend: ${{ needs.detect-changes.outputs.frontend }}"
          echo "- Terraform: ${{ needs.detect-changes.outputs.terraform }}"
          
          if [[ "${{ needs.detect-changes.outputs.frontend }}" == "true" && "${{ needs.detect-changes.outputs.backend }}" == "false" && "${{ needs.detect-changes.outputs.terraform }}" == "false" ]]; then
            echo "Frontend-only deployment: Targeting S3 + CloudFront"
            terraform plan \
              -var="db_username=${{ secrets.DB_USERNAME }}" \
              -var="db_password=${{ secrets.DB_PASSWORD }}" \
              -target=aws_s3_bucket.s3-web \
              -target=aws_s3_bucket_website_configuration.s3-web-config \
              -target=aws_s3_bucket_policy.web \
              -target=aws_s3_bucket_public_access_block.s3-web-unblock \
              -target=aws_cloudfront_origin_access_control.web \
              -target=aws_cloudfront_distribution.web \
              -no-color
          elif [[ "${{ needs.detect-changes.outputs.backend }}" == "true" && "${{ needs.detect-changes.outputs.frontend }}" == "false" && "${{ needs.detect-changes.outputs.terraform }}" == "false" ]]; then
            echo "Backend-only deployment: Excluding S3 + CloudFront"
            terraform plan \
              -var="db_username=${{ secrets.DB_USERNAME }}" \
              -var="db_password=${{ secrets.DB_PASSWORD }}" \
              -target=aws_vpc.main \
              -target=aws_subnet.pub-sub \
              -target=aws_subnet.pri-sub-was \
              -target=aws_subnet.pri-sub-db \
              -target=aws_internet_gateway.igw \
              -target=aws_route_table.pub-rt \
              -target=aws_route_table.pri-rt \
              -target=aws_route_table_association.pub-associate \
              -target=aws_route_table_association.pri-associate-was \
              -target=aws_nat_gateway.nat \
              -target=aws_eip.eip \
              -target=aws_security_group.sg-alb \
              -target=aws_security_group.sg-was \
              -target=aws_security_group.sg-db \
              -target=aws_instance.ec2-1 \
              -target=aws_instance.ec2-2 \
              -target=aws_lb.alb \
              -target=aws_lb_target_group.alb-tg \
              -target=aws_lb_listener.alb-listner \
              -target=aws_lb_target_group_attachment.ec2-1 \
              -target=aws_lb_target_group_attachment.ec2-2 \
              -target=aws_db_instance.rds \
              -target=aws_db_subnet_group.main \
              -target=aws_iam_role.ec2_role \
              -target=aws_iam_instance_profile.ec2_profile \
              -target=aws_iam_role_policy_attachment.ec2_ssm_policy \
              -target=aws_vpc_endpoint.ssm \
              -target=aws_vpc_endpoint.ssm_messages \
              -target=aws_vpc_endpoint.ec2_messages \
              -target=aws_s3_bucket.ssm_logs \
              -target=aws_s3_bucket_versioning.ssm_logs \
              -target=aws_s3_bucket_server_side_encryption_configuration.ssm_logs \
              -no-color
          else
            echo "Full infrastructure deployment"
            terraform plan \
              -var="db_username=${{ secrets.DB_USERNAME }}" \
              -var="db_password=${{ secrets.DB_PASSWORD }}" \
              -no-color
          fi

      - name: Terraform Apply (Conditional Targeting)
        working-directory: ./terraform
        run: |
          if [[ "${{ needs.detect-changes.outputs.frontend }}" == "true" && "${{ needs.detect-changes.outputs.backend }}" == "false" && "${{ needs.detect-changes.outputs.terraform }}" == "false" ]]; then
            echo "Applying S3 + CloudFront only"
            terraform apply \
              -var="db_username=${{ secrets.DB_USERNAME }}" \
              -var="db_password=${{ secrets.DB_PASSWORD }}" \
              -target=aws_s3_bucket.s3-web \
              -target=aws_s3_bucket_website_configuration.s3-web-config \
              -target=aws_s3_bucket_policy.web \
              -target=aws_s3_bucket_public_access_block.s3-web-unblock \
              -target=aws_cloudfront_origin_access_control.web \
              -target=aws_cloudfront_distribution.web \
              -auto-approve -no-color
          elif [[ "${{ needs.detect-changes.outputs.backend }}" == "true" && "${{ needs.detect-changes.outputs.frontend }}" == "false" && "${{ needs.detect-changes.outputs.terraform }}" == "false" ]]; then
            echo "Applying backend infrastructure (excluding S3 + CloudFront)"
            terraform apply \
              -var="db_username=${{ secrets.DB_USERNAME }}" \
              -var="db_password=${{ secrets.DB_PASSWORD }}" \
              -target=aws_vpc.main \
              -target=aws_subnet.pub-sub \
              -target=aws_subnet.pri-sub-was \
              -target=aws_subnet.pri-sub-db \
              -target=aws_internet_gateway.igw \
              -target=aws_route_table.pub-rt \
              -target=aws_route_table.pri-rt \
              -target=aws_route_table_association.pub-associate \
              -target=aws_route_table_association.pri-associate-was \
              -target=aws_nat_gateway.nat \
              -target=aws_eip.eip \
              -target=aws_security_group.sg-alb \
              -target=aws_security_group.sg-was \
              -target=aws_security_group.sg-db \
              -target=aws_instance.ec2-1 \
              -target=aws_instance.ec2-2 \
              -target=aws_lb.alb \
              -target=aws_lb_target_group.alb-tg \
              -target=aws_lb_listener.alb-listner \
              -target=aws_lb_target_group_attachment.ec2-1 \
              -target=aws_lb_target_group_attachment.ec2-2 \
              -target=aws_db_instance.rds \
              -target=aws_db_subnet_group.main \
              -target=aws_iam_role.ec2_role \
              -target=aws_iam_instance_profile.ec2_profile \
              -target=aws_iam_role_policy_attachment.ec2_ssm_policy \
              -target=aws_vpc_endpoint.ssm \
              -target=aws_vpc_endpoint.ssm_messages \
              -target=aws_vpc_endpoint.ec2_messages \
              -target=aws_s3_bucket.ssm_logs \
              -target=aws_s3_bucket_versioning.ssm_logs \
              -target=aws_s3_bucket_server_side_encryption_configuration.ssm_logs \
              -auto-approve -no-color
          else
            echo "Applying full infrastructure"
            terraform apply \
              -var="db_username=${{ secrets.DB_USERNAME }}" \
              -var="db_password=${{ secrets.DB_PASSWORD }}" \
              -auto-approve -no-color
          fi

      - name: Get Terraform Outputs
        id: terraform
        working-directory: ./terraform
        run: |
          # 기존 기본 정보들
          EC2_IDS=$(terraform output -json ec2_instance_ids)
          EC2_PRIVATE_IPS=$(terraform output -json ec2_private_ips)
        
          EC2_ID_1=$(echo $EC2_IDS | jq -r '.[0]')
          EC2_ID_2=$(echo $EC2_IDS | jq -r '.[1]')
          EC2_PRIVATE_IP_1=$(echo $EC2_PRIVATE_IPS | jq -r '.[0]')
          EC2_PRIVATE_IP_2=$(echo $EC2_PRIVATE_IPS | jq -r '.[1]')
        
          echo "ec2-id-1=$EC2_ID_1" >> $GITHUB_OUTPUT
          echo "ec2-id-2=$EC2_ID_2" >> $GITHUB_OUTPUT
          echo "ec2-private-ip-1=$EC2_PRIVATE_IP_1" >> $GITHUB_OUTPUT
          echo "ec2-private-ip-2=$EC2_PRIVATE_IP_2" >> $GITHUB_OUTPUT
        
          ALB_DNS=$(terraform output -raw alb_dns_name || echo '')
          echo "alb-dns=$ALB_DNS" >> $GITHUB_OUTPUT
        
          echo "s3-bucket=$(terraform output -raw s3_bucket_name || echo '')" >> $GITHUB_OUTPUT
          echo "ssm-bucket=$(terraform output -raw ssm_bucket_name || echo '')" >> $GITHUB_OUTPUT
        
          # RDS endpoint에서 포트 제거
          RDS_ENDPOINT_RAW=$(terraform output -raw rds_endpoint || echo '')
          RDS_ENDPOINT=$(echo $RDS_ENDPOINT_RAW | cut -d':' -f1)
          echo "db-endpoint=$RDS_ENDPOINT" >> $GITHUB_OUTPUT
        
          echo "cloudfront-url=$(terraform output -raw cloudfront_domain_name || echo '')" >> $GITHUB_OUTPUT
          
          # 백엔드 API용 추가 정보들
          echo "vpc-id=$(terraform output -raw vpc_id || echo '')" >> $GITHUB_OUTPUT
          echo "vpc-cidr=$(terraform output -raw vpc_cidr_block || echo '')" >> $GITHUB_OUTPUT
          echo "public-subnet-ids=$(terraform output -json public_subnet_ids || echo '[]')" >> $GITHUB_OUTPUT
          echo "private-subnet-ids-was=$(terraform output -json private_subnet_ids_was || echo '[]')" >> $GITHUB_OUTPUT
          echo "private-subnet-ids-db=$(terraform output -json private_subnet_ids_db || echo '[]')" >> $GITHUB_OUTPUT
          echo "internet-gateway-id=$(terraform output -raw internet_gateway_id || echo '')" >> $GITHUB_OUTPUT
          echo "nat-gateway-ids=$(terraform output -json nat_gateway_ids || echo '[]')" >> $GITHUB_OUTPUT
          
          # 보안 그룹 정보
          echo "security-group-alb-id=$(terraform output -raw security_group_alb_id || echo '')" >> $GITHUB_OUTPUT
          echo "security-group-was-id=$(terraform output -raw security_group_was_id || echo '')" >> $GITHUB_OUTPUT
          echo "security-group-db-id=$(terraform output -raw security_group_db_id || echo '')" >> $GITHUB_OUTPUT
          
          # EC2 추가 정보
          echo "ec2-public-ips=$(terraform output -json ec2_public_ips || echo '[]')" >> $GITHUB_OUTPUT
          echo "ec2-availability-zones=$(terraform output -json ec2_availability_zones || echo '[]')" >> $GITHUB_OUTPUT
          echo "ec2-instance-types=$(terraform output -json ec2_instance_types || echo '[]')" >> $GITHUB_OUTPUT
          echo "ec2-ami-id=$(terraform output -raw ec2_ami_id || echo '')" >> $GITHUB_OUTPUT
          
          # ALB 추가 정보
          echo "alb-arn=$(terraform output -raw alb_arn || echo '')" >> $GITHUB_OUTPUT
          echo "alb-availability-zones=$(terraform output -json alb_availability_zones || echo '[]')" >> $GITHUB_OUTPUT
          echo "alb-listener-arn=$(terraform output -raw alb_listener_arn || echo '')" >> $GITHUB_OUTPUT
          echo "alb-target-group-name=$(terraform output -raw alb_target_group_name || echo '')" >> $GITHUB_OUTPUT
          
          # RDS 추가 정보
          echo "rds-instance-identifier=$(terraform output -raw rds_instance_identifier || echo '')" >> $GITHUB_OUTPUT
          echo "rds-availability-zone=$(terraform output -raw rds_availability_zone || echo '')" >> $GITHUB_OUTPUT
          echo "rds-multi-az=$(terraform output -raw rds_multi_az || echo '')" >> $GITHUB_OUTPUT
          echo "rds-engine=$(terraform output -raw rds_engine || echo '')" >> $GITHUB_OUTPUT
          echo "rds-engine-version=$(terraform output -raw rds_engine_version || echo '')" >> $GITHUB_OUTPUT
          echo "rds-instance-class=$(terraform output -raw rds_instance_class || echo '')" >> $GITHUB_OUTPUT
          
          # S3 추가 정보
          echo "s3-bucket-region=$(terraform output -raw s3_bucket_region || echo '')" >> $GITHUB_OUTPUT
          echo "s3-website-endpoint=$(terraform output -raw s3_website_endpoint || echo '')" >> $GITHUB_OUTPUT
          
          # CloudFront 추가 정보
          echo "cloudfront-distribution-id=$(terraform output -raw cloudfront_distribution_id || echo '')" >> $GITHUB_OUTPUT
          echo "cloudfront-status=$(terraform output -raw cloudfront_status || echo '')" >> $GITHUB_OUTPUT

  # 서버 설정 (Ansible + SSM) - community.aws.aws_ssm 플러그인 방식
  setup-servers:
    needs: [detect-changes, deploy-infrastructure]
    if: |
      always() && 
      needs.deploy-infrastructure.result == 'success' &&
      (needs.detect-changes.outputs.ansible == 'true' || 
       needs.detect-changes.outputs.terraform == 'true' ||
       needs.detect-changes.outputs.backend == 'true' ||
       github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for EC2 instances to be ready for SSM
        run: |
          echo "Waiting for EC2 instances to be ready..."
          
          # EC2 인스턴스 상태 확인
          echo "Checking EC2 instance state..."
          aws ec2 describe-instances --instance-ids ${{ needs.deploy-infrastructure.outputs.ec2-id-1 }} \
            --query 'Reservations[0].Instances[0].State.Name' --output text
          
          # SSM 에이전트 상태 확인 (최대 5분 대기)
          for i in {1..30}; do
            SSM_STATUS=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=${{ needs.deploy-infrastructure.outputs.ec2-id-1 }}" \
              --query 'InstanceInformationList[0].PingStatus' --output text 2>/dev/null || echo "None")
            
            if [ "$SSM_STATUS" = "Online" ]; then
              echo "SSM Agent is ready"
              break
            else
              echo "Waiting for SSM Agent... ($i/30) - Current status: $SSM_STATUS"
              sleep 10
            fi
          done
          
          # 추가 안전 대기
          sleep 60

      - name: Install Ansible and AWS collections
        run: |
          pip install --upgrade pip
          pip install "ansible-core>=2.15,<2.17" "boto3>=1.28.0" "botocore>=1.31.0"
          ansible-galaxy collection install "amazon.aws:>=6.0.0,<7.0.0" --force
          ansible-galaxy collection install "community.aws:>=6.0.0,<7.0.0" --force

      - name: Verify AWS SSM plugin availability
        run: |
          ansible-doc -t connection aws_ssm

      - name: Create Ansible inventory with SSM connection
        working-directory: ./ansible
        run: |
          cat > inventory.ini << EOF
          [webservers]
          ${{ needs.deploy-infrastructure.outputs.ec2-id-1 }}
          ${{ needs.deploy-infrastructure.outputs.ec2-id-2 }}
          
          [webservers:vars]
          ansible_connection=aws_ssm
          ansible_aws_ssm_region=${{ env.AWS_REGION }}
          ansible_aws_ssm_bucket_name=${{ needs.deploy-infrastructure.outputs.ssm-bucket }}
          ansible_aws_ssm_timeout=60
          ansible_aws_ssm_retries=3
          EOF

      - name: Test Ansible connectivity
        working-directory: ./ansible
        run: |
          ansible webservers -i inventory.ini -m ping -vvv

      - name: Run Ansible setup playbook (MySQL 설치 포함)
        working-directory: ./ansible
        run: |
          ansible-playbook -i inventory.ini playbooks/setup-service.yaml \
            -e "rds_host=${{ needs.deploy-infrastructure.outputs.db-endpoint }}" \
            -e "db_user=${{ secrets.DB_USERNAME }}" \
            -e "db_password=${{ secrets.DB_PASSWORD }}" \
            -e "db_name=voting_db" \
            -v

  # 백엔드 빌드 및 배포 (Ansible + SSM)
  deploy-backend:
    needs: [detect-changes, deploy-infrastructure, setup-servers]
    if: |
      always() && 
      (needs.detect-changes.outputs.backend == 'true' || github.event_name == 'workflow_dispatch') &&
      needs.setup-servers.result == 'success'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Build with Gradle
        working-directory: ./backend
        run: |
          chmod +x gradlew
          ./gradlew bootJar -x test

      - name: Setup Python and Ansible
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install "ansible-core>=2.15,<2.17" "boto3>=1.28.0" "botocore>=1.31.0"
          ansible-galaxy collection install "amazon.aws:>=6.0.0,<7.0.0" --force
          ansible-galaxy collection install "community.aws:>=6.0.0,<7.0.0" --force

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Recreate Ansible inventory for db-config
        working-directory: ./ansible
        run: |
          cat > inventory.ini << EOF
          [webservers]
          ${{ needs.deploy-infrastructure.outputs.ec2-id-1 }}
          ${{ needs.deploy-infrastructure.outputs.ec2-id-2 }}
          
          [webservers:vars]
          ansible_connection=aws_ssm
          ansible_aws_ssm_region=${{ env.AWS_REGION }}
          ansible_aws_ssm_bucket_name=${{ needs.deploy-infrastructure.outputs.ssm-bucket }}
          ansible_aws_ssm_timeout=60
          ansible_aws_ssm_retries=3
          EOF

      - name: Deploy configuration via Ansible
        working-directory: ./ansible
        run: |
          ansible-playbook -i inventory.ini playbooks/db-config.yaml \
            -e "rds_endpoint=${{ needs.deploy-infrastructure.outputs.db-endpoint }}" \
            -e "rds_port=3306" \
            -e "database_name=voting_db" \
            -e "db_username=${{ secrets.DB_USERNAME }}" \
            -e "db_password=${{ secrets.DB_PASSWORD }}" \
            -e "ec2_instance_ids='${{ needs.deploy-infrastructure.outputs.ec2-id-1 }},${{ needs.deploy-infrastructure.outputs.ec2-id-2 }}'" \
            -e "alb_dns_name=${{ needs.deploy-infrastructure.outputs.alb-dns }}" \
            -e "alb_arn=${{ needs.deploy-infrastructure.outputs.alb-arn }}" \
            -e "alb_target_group_name=${{ needs.deploy-infrastructure.outputs.alb-target-group-name }}" \
            -e "alb_listener_arn=${{ needs.deploy-infrastructure.outputs.alb-listener-arn }}" \
            -e "alb_availability_zones='${{ needs.deploy-infrastructure.outputs.alb-availability-zones }}'" \
            -e "rds_instance_identifier=${{ needs.deploy-infrastructure.outputs.rds-instance-identifier }}" \
            -e "rds_engine=${{ needs.deploy-infrastructure.outputs.rds-engine }}" \
            -e "rds_engine_version=${{ needs.deploy-infrastructure.outputs.rds-engine-version }}" \
            -e "rds_instance_class=${{ needs.deploy-infrastructure.outputs.rds-instance-class }}" \
            -e "rds_availability_zone=${{ needs.deploy-infrastructure.outputs.rds-availability-zone }}" \
            -e "rds_multi_az=${{ needs.deploy-infrastructure.outputs.rds-multi-az }}" \
            -e "s3_bucket_name=${{ needs.deploy-infrastructure.outputs.s3-bucket }}" \
            -e "s3_bucket_region=${{ needs.deploy-infrastructure.outputs.s3-bucket-region }}" \
            -e "s3_website_endpoint=${{ needs.deploy-infrastructure.outputs.s3-website-endpoint }}" \
            -e "cloudfront_distribution_id=${{ needs.deploy-infrastructure.outputs.cloudfront-distribution-id }}" \
            -e "cloudfront_domain_name=${{ needs.deploy-infrastructure.outputs.cloudfront-url }}" \
            -e "cloudfront_status=${{ needs.deploy-infrastructure.outputs.cloudfront-status }}" \
            -e "vpc_id=${{ needs.deploy-infrastructure.outputs.vpc-id }}" \
            -e "vpc_cidr_block=${{ needs.deploy-infrastructure.outputs.vpc-cidr }}" \
            -e "public_subnet_ids='${{ needs.deploy-infrastructure.outputs.public-subnet-ids }}'" \
            -e "private_subnet_ids_was='${{ needs.deploy-infrastructure.outputs.private-subnet-ids-was }}'" \
            -e "private_subnet_ids_db='${{ needs.deploy-infrastructure.outputs.private-subnet-ids-db }}'" \
            -e "internet_gateway_id=${{ needs.deploy-infrastructure.outputs.internet-gateway-id }}" \
            -e "nat_gateway_ids='${{ needs.deploy-infrastructure.outputs.nat-gateway-ids }}'" \
            -e "security_group_alb_id=${{ needs.deploy-infrastructure.outputs.security-group-alb-id }}" \
            -e "security_group_was_id=${{ needs.deploy-infrastructure.outputs.security-group-was-id }}" \
            -e "security_group_db_id=${{ needs.deploy-infrastructure.outputs.security-group-db-id }}" \
            -e "ec2_public_ips='[]'" \
            -e "ec2_private_ips='${{ needs.deploy-infrastructure.outputs.ec2-private-ip-1 }},${{ needs.deploy-infrastructure.outputs.ec2-private-ip-2 }}'" \
            -e "ec2_availability_zones='${{ needs.deploy-infrastructure.outputs.ec2-availability-zones }}'" \
            -e "ec2_instance_types='${{ needs.deploy-infrastructure.outputs.ec2-instance-types }}'" \
            -e "ec2_ami_id=${{ needs.deploy-infrastructure.outputs.ec2-ami-id }}" \
            -v

      - name: Prepare JAR file for Ansible
        working-directory: ./ansible
        run: |
          mkdir -p files
          cp ../backend/build/libs/*.jar files/app.jar

      - name: Recreate Ansible inventory
        working-directory: ./ansible
        run: |
          cat > inventory.ini << EOF
          [webservers]
          ${{ needs.deploy-infrastructure.outputs.ec2-id-1 }}
          ${{ needs.deploy-infrastructure.outputs.ec2-id-2 }}
          
          [webservers:vars]
          ansible_connection=aws_ssm
          ansible_aws_ssm_region=${{ env.AWS_REGION }}
          ansible_aws_ssm_bucket_name=${{ needs.deploy-infrastructure.outputs.ssm-bucket }}
          ansible_aws_ssm_timeout=60
          ansible_aws_ssm_retries=3
          EOF


      - name: Deploy JAR via Ansible
        working-directory: ./ansible
        run: |
          ansible-playbook -i inventory.ini playbooks/jar-deploy.yaml \
            -e "jar_file=../files/app.jar" \
            -e "app_path=/opt/app" \
            -v

      - name: Health check via ALB
        run: |
          echo "Waiting for ALB health check..."
          sleep 30
          
          for i in {1..10}; do
            if curl -f "http://${{ needs.deploy-infrastructure.outputs.alb-dns }}/actuator/health"; then
              echo "Application is healthy via ALB!"
              break
            else
              echo "Attempt $i failed, retrying in 10 seconds..."
              sleep 10
            fi
          done

  # 프론트엔드 빌드 및 배포
  deploy-frontend:
    needs: [detect-changes, deploy-infrastructure]
    if: |
      always() && 
      (needs.detect-changes.outputs.frontend == 'true' || github.event_name == 'workflow_dispatch') &&
      needs.deploy-infrastructure.result == 'success'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build frontend
        working-directory: ./frontend
        run: npm run build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: |
          aws s3 sync frontend/dist/ s3://${{ needs.deploy-infrastructure.outputs.s3-bucket }}/ --delete

      - name: Invalidate CloudFront
        run: |
          S3_BUCKET_DOMAIN="${{ needs.deploy-infrastructure.outputs.s3-bucket }}.s3.amazonaws.com"
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Origins.Items[0].DomainName=='$S3_BUCKET_DOMAIN'].Id" \
            --output text)
          
          if [ -n "$DISTRIBUTION_ID" ] && [ "$DISTRIBUTION_ID" != "None" ]; then
            echo "Invalidating CloudFront distribution: $DISTRIBUTION_ID"
            aws cloudfront create-invalidation \
              --distribution-id $DISTRIBUTION_ID \
              --paths "/*"
          else
            echo "Warning: CloudFront distribution not found for bucket domain: $S3_BUCKET_DOMAIN"
          fi

  # 배포 완료 알림
  deployment-complete:
    needs: [detect-changes, deploy-infrastructure, setup-servers, deploy-backend, deploy-frontend]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Deployment Summary
        run: |
          echo "배포 완료!"
          echo ""
          echo "변경 감지 결과:"
          echo "- Backend: ${{ needs.detect-changes.outputs.backend }}"
          echo "- Frontend: ${{ needs.detect-changes.outputs.frontend }}"
          echo "- Terraform: ${{ needs.detect-changes.outputs.terraform }}"
          echo "- Ansible: ${{ needs.detect-changes.outputs.ansible }}"
          echo ""
          echo "서비스 URL:"
          if [ -n "${{ needs.deploy-infrastructure.outputs.cloudfront-url }}" ]; then
            echo "- Frontend: https://${{ needs.deploy-infrastructure.outputs.cloudfront-url }}"
          fi
          if [ -n "${{ needs.deploy-infrastructure.outputs.alb-dns }}" ]; then
            echo "- Backend API: http://${{ needs.deploy-infrastructure.outputs.alb-dns }}/api"
          fi
          echo ""
          echo "배포 상태:"
          echo "- 인프라: ${{ needs.deploy-infrastructure.result }}"
          echo "- 서버설정: ${{ needs.setup-servers.result }}"  
          echo "- 백엔드: ${{ needs.deploy-backend.result }}"
          echo "- 프론트엔드: ${{ needs.deploy-frontend.result }}"